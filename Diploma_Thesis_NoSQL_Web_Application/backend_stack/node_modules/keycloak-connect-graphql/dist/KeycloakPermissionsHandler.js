"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeycloakPermissionsHandler = void 0;
class KeycloakPermissionsHandler {
    constructor(keycloak, token, config) {
        var _a;
        this.keycloak = keycloak;
        this.config = config;
        this.permissionsToken = token;
        this.req = {
            headers: {
                authorization: "Bearer " + ((_a = this.permissionsToken) === null || _a === void 0 ? void 0 : _a.token)
            },
            kauth: {
                grant: {
                    access_token: this.permissionsToken
                }
            }
        };
    }
    handlePermissions(permissions, handler) {
        for (let i = 0; i < permissions.length; i++) {
            const expected = permissions[i].split(':');
            let resource = expected[0];
            let scope = undefined;
            if (expected.length > 1) {
                resource = expected.slice(0, expected.length - 1).join(':');
                scope = expected[expected.length - 1];
            }
            if (!handler(resource, scope)) {
                return false;
            }
        }
        return true;
    }
    async hasPermission(resources) {
        var _a, _b, _c;
        if (!this.permissionsToken) {
            return false;
        }
        let expectedPermissions;
        if (typeof resources === 'string') {
            expectedPermissions = [resources];
        }
        else {
            expectedPermissions = resources;
        }
        if (expectedPermissions.length === 0) {
            return true;
        }
        // try with cached permissions
        if (this.handlePermissions(expectedPermissions, (resource, scope) => {
            if (this.permissionsToken && this.permissionsToken.hasPermission(resource, scope)) {
                return true;
            }
            return false;
        })) {
            return true;
        }
        // make request
        let authzRequest = {
            audience: (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.resource_server_id) !== null && _b !== void 0 ? _b : this.keycloak.getConfig().resource,
            permissions: new Array(),
        };
        this.handlePermissions(expectedPermissions, (resource, scope) => {
            const permissions = { id: resource, scopes: new Array() };
            if (scope) {
                permissions.scopes = [scope];
            }
            authzRequest['permissions'].push(permissions);
            return true;
        });
        if ((_c = this.config) === null || _c === void 0 ? void 0 : _c.claims) {
            const claims = this.config.claims(this.req);
            if (claims) {
                authzRequest.claim_token = Buffer.from(JSON.stringify(claims)).toString('base64');
                authzRequest.claim_token_format = 'urn:ietf:params:oauth:token-type:jwt';
            }
        }
        try {
            authzRequest.response_mode = undefined;
            const grant = await this.keycloak.checkPermissions(authzRequest, this.req);
            const token = grant.access_token;
            if (token && this.handlePermissions(expectedPermissions, (resource, scope) => {
                if (!token.hasPermission(resource, scope)) {
                    return false;
                }
                return true;
            })) {
                return true;
            }
            return false;
        }
        catch (err) {
            return false;
        }
    }
}
exports.KeycloakPermissionsHandler = KeycloakPermissionsHandler;
//# sourceMappingURL=KeycloakPermissionsHandler.js.map